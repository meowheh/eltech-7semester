/*Задание: Написать две программы (Поставщик и Потребитель), которые работают с циклическим буфером ограниченного размера, 
расположенным в разделяемой памяти. Доступ к буферу и синхронизация работы Поставщика и Потребителя должны быть реализованы с помощью семафоров.
Поставщик выделяет буфер и семафоры, читает по одному символу из файла и записывает его в буфер. Потребитель считывает по одному символу из
буфера и выводит их на экран. Если буфер пустой, то Потребитель должен пассивно ждать, пока Поставщик не занесет туда хотя бы один символ. Если
буфер полностью заполнен, то Поставщик должен пассивно ждать, пока Потребитель не извлечет из него по крайней мере один символ. Поставщик
заканчивает свою работу, как только прочитает последний символ из файла и убедится, что Потребитель его прочитал. Потребитель заканчивает свою
работу при отсутствии символов в буфере и завершении работы Поставщика. */

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <stdlib.h>
#include <assert.h>
#include <iostream>
#include <unistd.h>
#include <fstream>
#include <stdio.h>

using namespace std;

const int SEM_WRITE = 0,
          SEM_READ = 1,
          SEM_END = 2;

int main()
{
    int shmid, 
        semid,
        *buff;
    short buffSize;

    key_t key = 150;

    buffSize = 5;

     //запрос на разделяемый сегмент памяти
    if ((shmid = shmget(key, 128, IPC_CREAT | 0666)) == -1)
        perror("shmget returned -1");

    //включение разделяемой памяти в пространство процесса
    buff = (int*)shmat(shmid, NULL, 0);
  
    //создаем множественный семафор(с количеством простых семафоров равным 3)
    if ((semid = semget(key, 3, IPC_CREAT | 0666)) == -1)
        perror("semget returned -1");

    //объединение для передачи в функцию smctl
    union semaphEmun
    {
        int val;
        struct semid_ds *buf;
        ushort array [2];
    } setup;

    short values[3] = {5, 0, 0};
    semctl(semid, 3, SETALL, values);

    //создаем списки команд для работы с множественным семафором
    struct sembuf operations[3];
    //инициализируем список команд для записи
    operations[SEM_WRITE].sem_num = SEM_WRITE;  //индекс простого семафора
    operations[SEM_WRITE].sem_op = -1;          //уменьшение на 1
    //инициализируем список команд для чтения
    operations[SEM_READ].sem_num = SEM_READ;  
    operations[SEM_READ].sem_op = 1;            //увеличение на 1 - открываем семафор на чтение
    //инициализируем список команд для определения завершения работы
    operations[SEM_END].sem_num = SEM_END;
    operations[SEM_END].sem_op = -1;           //уменьшение на 1 - включаем в очередь к семафору

    ifstream file;
    file.open("file.txt", ios::app);
    char c;
    int writeIndex = 0;
    while(!file.eof())
    {
        //считываем символ из файла
        file.get(c);
        //выполняем операцию семафора для записи (1 - количество выполняемых операций, отсчет от первого элемента operations)
        semop(semid, operations, 1);
        //устанавливаем в разделяемую память символ
        buff[writeIndex] = c;
        //увеличиваем индекс следующего символа
        writeIndex++;
        //выполняем операцию семафора для чтения (1 - количество выполняемых операций, отсчет от второго элемента operations)
        semop(semid, operations + 1, 1);
    }

    //устанавливаем спец символ конца файла
    buff[writeIndex] = EOF;
    //выполняем операцию семафора определения завершения работы
    semop(semid, operations + 2, 1);
    //закрываем файл и уничтожаем разделяемую память
    file.close();
    
    semctl(semid, IPC_RMID, 0); // Удаляем множество семафоров
    shmdt((void*)buff); // Исключаем сегмент разделяемой памяти из адресного пространства текущего процесса
    shmctl(shmid, IPC_RMID, 0);
   

} 